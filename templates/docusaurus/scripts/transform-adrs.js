#!/usr/bin/env node
/**
 * Transform ADRs for Docusaurus
 *
 * Reads ADR files from decisions/ and writes them to docs/decisions/
 * with Docusaurus frontmatter, RFC keyword highlighting, and cross-references.
 */

const fs = require('fs');
const path = require('path');
const { escapeMdxUnsafe } = require('./mdx-escape');

const ADRS_SOURCE = path.join(__dirname, '../../docs/decisions');
const ADRS_DEST = path.join(__dirname, '../../docs-generated/decisions');

// Read baseUrl from docusaurus.config.ts
const configPath = path.join(__dirname, '../docusaurus.config.ts');
let BASE_URL = '';
if (fs.existsSync(configPath)) {
  const configContent = fs.readFileSync(configPath, 'utf-8');
  const baseUrlMatch = configContent.match(/baseUrl:\s*['"]([^'"]+)['"]/);
  BASE_URL = baseUrlMatch ? baseUrlMatch[1].replace(/\/$/, '') : '';
}

// RFC prefix to emoji and spec path mapping (generated by build-rfc-mapping.js)
let RFC_MAPPING = {};
let RFC_EMOJIS = {};
try {
  RFC_MAPPING = require('../src/data/rfc-mapping.json');
  RFC_EMOJIS = require('../src/data/rfc-emojis.json');
} catch (e) {
  // Mapping files not yet generated
}

const ADR_EMOJI = '\ud83d\udcdd';

function buildAdrMapping() {
  const mapping = {};
  if (!fs.existsSync(ADRS_SOURCE)) return mapping;

  const files = fs.readdirSync(ADRS_SOURCE);
  for (const file of files) {
    if (!file.endsWith('.md')) continue;
    if (file === '0000-template.md' || file === 'README.md') continue;

    const match = file.match(/^(\d{4})-/);
    if (match) {
      const number = match[1];
      const slug = file.replace(/\.md$/, '');
      mapping[number] = `/decisions/${slug}`;
    }
  }
  return mapping;
}

const ADR_MAPPING = buildAdrMapping();

function extractTitle(content) {
  const match = content.match(/^#\s+(.+)$/m);
  return match ? match[1].trim() : 'Untitled ADR';
}

function extractMetadata(content) {
  const statusMatch = content.match(/^status:\s*"?([^"\n]+)"?/m);
  const dateMatch = content.match(/^date:\s*"?([^"\n]+)"?/m);
  const dmMatch = content.match(/^decision-makers:\s*"?([^"\n]+)"?/m);

  let status = statusMatch ? statusMatch[1].trim() : null;
  if (!status) {
    const sectionMatch = content.match(/##\s+Status\s*\n\s*\n\s*([^\n]+)/);
    status = sectionMatch ? sectionMatch[1].trim() : 'unknown';
  }

  return {
    status: status,
    date: dateMatch ? dateMatch[1].trim() : 'unknown',
    dm: dmMatch ? dmMatch[1].trim() : 'unknown'
  };
}

function escapeJsxLikeTags(content) {
  const htmlTags = ['div', 'span', 'a', 'p', 'br', 'hr', 'img', 'ul', 'ol', 'li', 'table', 'tr', 'td', 'th', 'thead', 'tbody', 'pre', 'code', 'blockquote', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'strong', 'em', 'b', 'i'];

  const lines = content.split('\n');
  return lines.map(line => {
    let result = '';
    let i = 0;
    while (i < line.length) {
      if (line[i] === '`') {
        const start = i;
        i++;
        while (i < line.length && line[i] !== '`') { i++; }
        if (i < line.length) { i++; }
        result += line.slice(start, i);
      } else {
        const remaining = line.slice(i);
        const tagMatch = remaining.match(/^<([a-z][a-z0-9_-]*(?:\|[a-z][a-z0-9_-]*)*)>/i);
        if (tagMatch && !htmlTags.includes(tagMatch[1].split('|')[0].toLowerCase())) {
          result += `\\<${tagMatch[1]}\\>`;
          i += tagMatch[0].length;
        } else if (remaining.match(/^<\d/)) {
          result += '\\<';
          i++;
        } else {
          result += line[i];
          i++;
        }
      }
    }
    return result;
  }).join('\n');
}

function escapeBidirectionalArrows(content) {
  return content.replace(/<-+>/g, (match) => {
    return match.replace(/</g, '&lt;').replace(/>/g, '&gt;');
  });
}

function transformRfcKeywords(content) {
  const keywordPattern = /\b(MUST NOT|SHALL NOT|SHOULD NOT|MUST|SHALL|REQUIRED|SHOULD|RECOMMENDED|MAY|OPTIONAL)\b/g;
  const keywordClasses = {
    'MUST NOT': 'must', 'SHALL NOT': 'shall', 'SHOULD NOT': 'should',
    'MUST': 'must', 'SHALL': 'shall', 'REQUIRED': 'required',
    'SHOULD': 'should', 'RECOMMENDED': 'recommended',
    'MAY': 'may', 'OPTIONAL': 'optional',
  };

  const lines = content.split('\n');
  return lines.map(line => {
    if (line.startsWith('```') || line.startsWith('#') || line.startsWith('    ')) return line;
    if (line.match(/^`[^`]+`$/)) return line;
    return line.replace(keywordPattern, (match) => {
      const cls = keywordClasses[match];
      return `<span className="rfc-keyword ${cls}">${match}</span>`;
    });
  }).join('\n');
}

function escapeCurlyBraces(content) {
  const lines = content.split('\n');
  return lines.map(line => {
    if (line.includes('</') || line.match(/<[A-Z]/)) return line;
    return line.replace(/\{([a-zA-Z_][a-zA-Z0-9_-]*)\}/g, '\\{$1\\}');
  }).join('\n');
}

function transformRfcReferences(content) {
  const rfcPattern = /\b([A-Z]+)-(\d{3,4})\b/g;
  const lines = content.split('\n');
  let inCodeBlock = false;

  return lines.map(line => {
    if (line.startsWith('```')) { inCodeBlock = !inCodeBlock; return line; }
    if (inCodeBlock || line.startsWith('#')) return line;
    if (line.trim().startsWith('<') && !line.includes('className="rfc-keyword')) return line;

    return line.replace(rfcPattern, (match, prefix, number) => {
      const specPath = RFC_MAPPING[prefix];
      const emoji = RFC_EMOJIS[prefix];
      if (!specPath) return match;
      const displayText = emoji ? `${emoji} ${match}` : match;
      const anchorId = match.toLowerCase();
      return `<a href="${BASE_URL}${specPath}#${anchorId}" className="rfc-ref">${displayText}</a>`;
    });
  }).join('\n');
}

function transformConsequenceKeywords(content) {
  const lines = content.split('\n');
  let inCodeBlock = false;

  return lines.map(line => {
    if (line.startsWith('```')) { inCodeBlock = !inCodeBlock; return line; }
    if (inCodeBlock) return line;
    return line.replace(/^(\s*[\*\-]\s+)(Good|Bad|Neutral|Meh|Okay)(,)/i, (match, prefix, keyword, comma) => {
      const normalizedKeyword = keyword.charAt(0).toUpperCase() + keyword.slice(1).toLowerCase();
      const cssClass = normalizedKeyword.toLowerCase();
      return `${prefix}<span className="consequence-keyword ${cssClass}">${normalizedKeyword}</span>${comma}`;
    });
  }).join('\n');
}

function transformAdrReferences(content) {
  const adrPattern = /\bADR-(\d{4})\b/g;
  const lines = content.split('\n');
  let inCodeBlock = false;

  return lines.map(line => {
    if (line.startsWith('```')) { inCodeBlock = !inCodeBlock; return line; }
    if (inCodeBlock || line.startsWith('#')) return line;
    if (line.trim().startsWith('<') && !line.includes('className="rfc-keyword') && !line.includes('className="rfc-ref')) return line;

    return line.replace(adrPattern, (match, number) => {
      const adrPath = ADR_MAPPING[number];
      if (!adrPath) return match;
      const displayText = `${ADR_EMOJI} ${match}`;
      return `<a href="${BASE_URL}${adrPath}" className="rfc-ref">${displayText}</a>`;
    });
  }).join('\n');
}

function fixMarkdownLinks(content) {
  return content.replace(/\]\(((?!https?:\/\/)[^)]*?)\.md(#[^)]*?)?\)/g, ']($1$2)');
}

function fixCrossSectionPaths(content) {
  return content.replace(/\]\(\.\.\/openspec\/specs\//g, '](../specs/');
}

function transformAdr(srcPath, destPath, fileName) {
  let content = fs.readFileSync(srcPath, 'utf-8');

  if (fileName === '0000-template.md' || fileName === 'README.md') return;

  const isNumberedAdr = /^\d{4}-/.test(fileName);
  const title = extractTitle(content);
  const { status, date, dm } = extractMetadata(content);

  const contentWithoutFrontmatter = content.replace(/^---[\s\S]*?---/, '').trim();

  let escapedContent = fixMarkdownLinks(contentWithoutFrontmatter);
  escapedContent = fixCrossSectionPaths(escapedContent);
  escapedContent = escapeJsxLikeTags(escapedContent);
  escapedContent = escapeBidirectionalArrows(escapedContent);
  escapedContent = escapeCurlyBraces(escapedContent);
  escapedContent = transformRfcKeywords(escapedContent);
  escapedContent = transformRfcReferences(escapedContent);
  escapedContent = transformAdrReferences(escapedContent);
  escapedContent = transformConsequenceKeywords(escapedContent);

  const slug = fileName.replace(/\.md$/, '');

  let sidebarLabel;
  if (isNumberedAdr) {
    const adrNum = fileName.split('-')[0];
    const titleWithoutAdr = title.replace(/^ADR-\d+:\s*/, '');
    sidebarLabel = `ADR-${adrNum}: ${titleWithoutAdr}`;
  } else {
    sidebarLabel = title;
  }

  const badgeHeader = isNumberedAdr ? `
<FieldGroup>
  <Field label="Status">
    <StatusBadge status="${status.toUpperCase()}" />
  </Field>
  <Field label="Date">
    <DateBadge date="${date}" />
  </Field>
  <Field label="Decision Makers">${dm}</Field>
</FieldGroup>
` : '';

  const frontmatter = `---\ntitle: "${title}"
sidebar_label: "${sidebarLabel}"
slug: /decisions/${slug}
---
${badgeHeader}
`;

  fs.mkdirSync(path.dirname(destPath), { recursive: true });
  fs.writeFileSync(destPath, frontmatter + escapeMdxUnsafe(escapedContent));
}

function main() {
  console.log('Transforming ADRs...');

  if (!fs.existsSync(ADRS_SOURCE)) {
    console.log('  No decisions directory found, skipping ADR transform');
    return;
  }

  if (fs.existsSync(ADRS_DEST)) {
    fs.rmSync(ADRS_DEST, { recursive: true });
  }
  fs.mkdirSync(ADRS_DEST, { recursive: true });

  fs.writeFileSync(path.join(ADRS_DEST, '_category_.json'), JSON.stringify({
    label: 'Architecture Decisions',
    position: 2,
    link: {
      type: 'generated-index',
      description: 'Architecture Decision Records (ADRs).'
    }
  }, null, 2));

  const files = fs.readdirSync(ADRS_SOURCE);
  let fileCount = 0;

  for (const file of files) {
    if (!file.endsWith('.md')) continue;
    if (file === '0000-template.md' || file === 'README.md') continue;

    const srcPath = path.join(ADRS_SOURCE, file);
    const destPath = path.join(ADRS_DEST, file.replace(/\.md$/, '.mdx'));
    transformAdr(srcPath, destPath, file);
    fileCount++;
  }

  console.log(`  Transformed ${fileCount} ADR files`);
}

main();
